# -*- coding: utf-8 -*-
"""05ex_pandas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17ug2da9sRX_83UDKh23gKiu6UI_-At2I

This exercise consists in analyzing a dataset containg timing information from a series of Time-to-Digital-Converters (TDC) implemented in a pair of FPGAs. Each measurement (i.e. each row of the input file) consists of a flag that specifies the type of message ('HEAD', which in this case is always 1), two addresses of the TDC providing the signal ('FPGA' and 'TDC_CHANNEL'), and the timing information ('ORBIT_CNT', 'BX_COUNTER', and 'TDC_MEAS'). Each TDC count corresponds to 25/30 ns, whereas a unit of BX_COUNTER corresponds to 25 ns, and the ORBIT_CNT is increased every 'x' BX_COUNTER. This allows to store the time in a similar way to hours, minutes and seconds.
"""

# If haven't downloaded it yet, please get the data file with wget
#!wget https://www.dropbox.com/s/xvjzaxzz3ysphme/data_000637.txt -P ./data/

"""1\. Create a Pandas DataFrame reading N rows of the `data/data_000637.txt` dataset. Choose N to be smaller than or equal to the maximum number of rows and larger that 10k (check the documentation)."""

import pandas as pd
import numpy as np
data = pd.read_csv('/content/data_000637.txt',nrows=15000) #this gives N rows
data_full = pd.read_csv('/content/data_000637.txt')
data.head()
df = pd.DataFrame(data)
df_full = pd.DataFrame(data_full)

"""2. Estimate the number of BX in a ORBIT (the value x).

Hint: check when the BX counter reaches the maximum value before being reset to 0.
"""

BX_max_value = df_full.BX_COUNTER.max()
print("Max BX number in a orbit: "+str(BX_max_value))

"""3\. Create a new column with the absolute time in ns (as a combination of the other three columns with timing information) since the beginning of the data acquisition."""

import datetime as dt

import datetime as dt
# the one-liner command
df['TIMENS'] = data['TDC_MEAS'] * 25 / 30 + data['BX_COUNTER'] * 25

data
s = pd.Series(pd.to_timedelta(df['TIMENS'], unit='ns')) #nanosecond to second
df['TOTAL_TIME(sec)'] = s.dt.total_seconds() #new column

df

"""4. Find out the duration of the data taking in hours, minutes and seconds, by using the features of the Time Series. Perform this check reading the whole dataset"""

#Each TDC count corresponds to 25/30 ns,
#whereas a unit of BX_COUNTER corresponds to 25 ns, 
#and the ORBIT_CNT is increased every 'x' BX_COUNTER. 
#This allows to store the time in a similar way to hours, 
#minutes and seconds.

import datetime as dt



# the one-liner command
df['TIMENS'] = data['TDC_MEAS'] * 25 / 30 + data['BX_COUNTER'] * 25

data

for i in range(1,len(df['TIMENS'])):
    df['TIMENS'][i]+=df['TIMENS'][i-1]
    
#this is for calculating the total time by adding every row from top to bottom

df

"""5\. Use the `.groupby()` method to find out the noisy channels, i.e. the TDC channels with most counts (print to screen the top 3 and the corresponding counts)"""

import numpy as np

df.groupby('TDC_CHANNEL').max()[-3:]

"""6\. Count the number of non-empty orbits (i.e. the number of orbits with at least one hit). """

tdc_139 = df[(df['TDC_CHANNEL'])==139]
count_unique_139 = len(set(tdc_139.ORBIT_CNT)) #make it set to find the unique orbit counts
tdc_139
print("Number of unique orbits with at least one measurement from TDC_CHANNEL=139: " + str(count_unique_139))
tdc_139

"""7. Count the number of unique orbits with at least one measurement from TDC_CHANNEL=139."""

tdc_139 = df[(df['TDC_CHANNEL'])==139]
count_unique_139 = len(set(tdc_139.ORBIT_CNT)) #make it set to find the unique orbit counts
tdc_139
print("Number of unique orbits with at least one measurement from TDC_CHANNEL=139: " + str(count_unique_139))
tdc_139

"""8. Create two Series (one for each FPGA) that have the TDC channel as index, and the number of counts for the corresponding TDC channel as values."""

