# -*- coding: utf-8 -*-
"""04ex_numpy .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10kRbzQokcNlKECCu4Qqo-IVKdFewda4V

1\. Find the total mean, and the mean for each row and column of the following matrix:

```python
m = np.arange(12).reshape((3,4))
```
"""

import numpy as np
m = np.arange(12).reshape((3,4)) #creates 3x4 matrix
m

total_mea = np.mean(m) #mean() function finds the mean value of matrix elements

#did this to every row
row1 = np.mean(m[0])
row2 = np.mean(m[0])
row3 = np.mean(m[0])


#then for every column
col1 = np.mean(m[:,0])
col2 = np.mean(m[:,1])
col3 = np.mean(m[:,2])
col4 = np.mean(m[:,3])

print("Total mean: "+str(total_mea))
print("Row1 mean: "+str(row1))
print("Row2 mean: "+str(row2))
print("Row3 mean: "+str(row3))
print("Column1 mean: "+str(col1))
print("Column2 mean: "+str(col2))
print("Column3 mean: "+str(col3))
print("Column4 mean: "+str(col4))

"""2\. Find the outer product of the following vectors:

```python
u = np.array([1, 3, 5, 7])
v = np.array([2, 4, 6, 8])
```

Use different methods to do this:

   1. Using the function `outer` in numpy
   2. Using a nested `for` loop or a list comprehension
   3. Using numpy broadcasting operations
"""

u = np.array([1, 3, 5, 7])
v = np.array([2, 4, 6, 8])

#1
num_out = np.outer(u,v)

print("1. Using outer function in numpy: \n"+str(num_out))


#2
mul = []  #blank array
for element_u in u: 
    mul2 = [] #blank array 2
    for element_v in v:
        mul2.append(element_u*element_v) #for every element in u and v we will append it to mul2 list
                                        #after every row append it to the mul list
    mul.append(mul2)
mul = np.array(mul)


print("2. Using nested for loop: \n"+str(mul))
#3 

list_comp = np.array([items_u*items_v for items_u in u for items_v in v]).reshape(4,4) #i had to reshape it

print("3. Using list comprehension: \n"+str(list_comp))

#4 broadcasting opearations

print("4. Using numpy broadcasting operations \n"+str(u*v.reshape(4,1)))

"""3. Matrix masking

Create a 10 by 6 matrix of float random numbers, distributed between 0 and 3 according to a flat distribution.

After creating the matrix, set all entries<0.3  to zero using a mask.



"""

#print(np.linspace(start = 0, stop = 3, num=60, endpoint=True, retstep=True, dtype=None, axis=0,step = 0.1).reshape(10,6))
arr1 = np.linspace(start = 0, stop = 3, num=60, endpoint=True, retstep=False, dtype=None, axis=0)
arr2 = [arr1[i]-arr1[i]%1 for i in range(len(arr1)) if arr1[i]%1<0.3] #filtered 0.3
arr3 = [arr1[i] for i in range(len(arr1)) if arr1[i]%1>0.3] #rest of the matrix
master_arr = list(arr2)+list(arr3) #summed them together
master_arr = sorted(np.array(master_arr)) #sorted the values
print("Matrix : \n"+str(master_arr))

"""4\. Use `np.linspace` to create an array of 100 numbers between 0 and 2Ï€ (inclusive).

  * Extract every 10th element using the slice notation
  * Reverse the array using the slice notation
  * Extract elements where the absolute difference between the sin and cos functions evaluated for that element is $< 0.1$
  * **Optional**: make a plot showing the sin and cos functions and indicate where they are close
"""

arr1 = np.linspace(start = 0, stop = np.pi*2, num=100, endpoint=True, retstep=False, dtype=None, axis=0)
arr_reversed = arr1[::-1]
print("Reverse the array using the slice notation \n" +str(arr_reversed))
arr_10th = arr1[::10]
print("Extract every 10th element using the slice notation \n"+str(arr_10th))

#used where function to make the condition
arr_sin_cos = np.where(np.absolute(np.sin(arr1)-np.cos(arr1))<0.1,arr1,None)

arr_sin_cos = set(arr_sin_cos) #make it set to get rid of Nones that where created
arr_sin_cos.remove(None) #then removed the None
print("Extracted elements absolute difference between the sin and cos functions evaluated for that element is  <0.1: \n"+ str(arr_sin_cos))



"""5\. Create a matrix that shows the 10 by 10 multiplication table.

 * Find the trace of the matrix
 * Extract the anti-diagonal matrix (this should be ```array([10, 18, 24, 28, 30, 30, 28, 24, 18, 10])```)
 * Extract the diagonal offset by 1 upwards (this should be ```array([ 2,  6, 12, 20, 30, 42, 56, 72, 90])```)
"""

ten_by_ten = np.arange(1,11)
ten_by_ten = ten_by_ten*ten_by_ten[:,None]

print("10x10 matrix: \n"+str(ten_by_ten))
trace = np.trace(ten_by_ten) #first trace



flipped = np.fliplr(ten_by_ten) #flipped it

anti_diag = np.diag(flipped) 
print("Anti-Diagonal Matrix: \n"+str(anti_diag))

one_upwards = [ten_by_ten[i][i-1] for i in range(1,len(ten_by_ten))] #created a list comph for this
print("diagonal offset by 1 upwards Matrix: \n"+str(one_upwards))

"""6\. Use broadcasting to create a grid of distances.

Route 66 crosses the following cities in the US: Chicago, Springfield, Saint-Louis, Tulsa, Oklahoma City, Amarillo, Santa Fe, Albuquerque, Flagstaff, Los Angeles
The corresponding positions in miles are: 0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448

  * Build a 2D grid of distances among each city along Route 66
  * Convert the distances in km
"""

cities = [ "Chicago", "Springfield", "Saint-Louis", "Tulsa", "Oklahoma City", "Amarillo","Santa Fe", "Albuquerque", "Flagstaff", "Los Angeles"]
distances = [0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448]
grid = np.tile(distances,len(distances)) #create tile over it for distance map

print("2D grid:")
grid

# 1 mile = 1.609344 km


f = lambda x: x * 1.609344  #created lambda function 

print("Km Grid:")
km_grid = np.array([i*1.609344 for i in grid]).reshape(grid.shape)
km_grid

"""7. Prime numbers sieve

Compute the prime numbers in the 0-N (start with N=99) range with a sieve (mask).

Constract a shape (N,) boolean array, which is the mask
Identify the multiples of each number starting from 2 and set accordingly the corresponding mask element
Apply the mask to obtain an array of ordered prime numbers
Check the performances (with timeit); how does it scale with N?
Implement the optimization suggested in the sieve of Eratosthenes
"""

def prime_computer(N):
    
    tmp = np.ones(N, dtype=bool) #created all boolean array
    tmp[0] = tmp[1] = False #no need to look for 0 and 1 we are going to start from 2
    for i in range(2, N):
        # We could use a lower upper bound for this loop, but I don't want to bother with
        # getting the rounding right on the sqrt handling.
        if tmp[i]: #for every element
            tmp[i*i::i] = False #if something has a divived make it false and all their multiples
    return np.flatnonzero(tmp)

import timeit

start_time = timeit.default_timer()
prime_computer(100)
print("N=100 time(sec): "+str(timeit.default_timer() - start_time))
print(prime_computer(100))

start_time = timeit.default_timer()
prime_computer(1000000)
print("N=1000000 time(sec): "+str(timeit.default_timer() - start_time))
print(prime_computer(1000000))

"""8. Diffusion using random walk

Consider a simple random walk process: at each step in time, a walker jumps right or left (+1 or -1) with equal probability. The goal is to find the typical distance from the origin of many random walkers after a given amount of time.

Hint: create a 2D array where each row represents a walker, and each column represents a time step.

Take 1000 walkers and let them walk for 200 steps
Use randint to create a 2D array of size  with values -1 or 1
Calculate the walking distances for each walker (e.g. by summing the elements in each row)
Take the square of the previously-obtained array (element-wise)
Compute the mean of the squared distances at each step (i.e. the mean along the columns)
Optional: plot the average distances () as a function of time (step)
"""

import numpy as np
walkers = 1000
steps = 200
x = np.random.randint(0,2,(walkers,steps))
a[a == 0] = -1
print("walkers x steps  with values -1 or 1: \n", a)

walking_distances = a.sum(axis = 1)
print('the walking distances: \n',walking_distances)

walking_distances_squared = np.square(walking_distances)

mean_squared_distances = np.mean(np.cumsum(a, axis = 1)**2 , axis = 0)
print('the mean: \n',mean_squared_distances)