# -*- coding: utf-8 -*-
"""05ex_pandas .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I9t0P8tyFzPNExdXS9qbYTuwGq-lhOVf

This exercise consists in analyzing a dataset containg timing information from a series of Time-to-Digital-Converters (TDC) implemented in a pair of FPGAs. Each measurement (i.e. each row of the input file) consists of a flag that specifies the type of message ('HEAD', which in this case is always 1), two addresses of the TDC providing the signal ('FPGA' and 'TDC_CHANNEL'), and the timing information ('ORBIT_CNT', 'BX_COUNTER', and 'TDC_MEAS'). Each TDC count corresponds to 25/30 ns, whereas a unit of BX_COUNTER corresponds to 25 ns, and the ORBIT_CNT is increased every 'x' BX_COUNTER. This allows to store the time in a similar way to hours, minutes and seconds.
"""

# If haven't downloaded it yet, please get the data file with wget
#!wget https://www.dropbox.com/s/xvjzaxzz3ysphme/data_000637.txt -P ./data/

"""1\. Create a Pandas DataFrame reading N rows of the `data/data_000637.txt` dataset. Choose N to be smaller than or equal to the maximum number of rows and larger that 10k (check the documentation)."""

import pandas as pd
import numpy as np
data = pd.read_csv('/content/data_000637.txt',nrows=15000) #this gives N rows
data_full = pd.read_csv('/content/data_000637.txt')
data.head()
df = pd.DataFrame(data)
df_full = pd.DataFrame(data_full)
print(df)

"""2. Estimate the number of BX in a ORBIT (the value x).

Hint: check when the BX counter reaches the maximum value before being reset to 0.
"""

BX_max_value = df_full.BX_COUNTER.max()
print("Max BX number in a orbit: "+str(BX_max_value))

"""3\. Create a new column with the absolute time in ns (as a combination of the other three columns with timing information) since the beginning of the data acquisition."""

df['TIME_ns'] = df.apply(lambda ns: ns.TDC_CHANNEL + ns.BX_COUNTER + ns.TDC_MEAS, axis = 1)
df['TIME_ns'] = pd.to_datetime(df['TIME_ns'])
print(df)

"""4. Find out the duration of the data taking in hours, minutes and seconds, by using the features of the Time Series. Perform this check reading the whole dataset"""

df['DURATION'] = df['TIME_ns'].dt.time
print(df)

df

"""5\. Use the `.groupby()` method to find out the noisy channels, i.e. the TDC channels with most counts (print to screen the top 3 and the corresponding counts)"""

noisy_channels = df.groupby(['TDC_CHANNEL'])['BX_COUNTER']
noisy_channels = noisy_channels.max()
df1 = pd.DataFrame(noisy_channels.head(3))
print(df1)

"""6\. Count the number of non-empty orbits (i.e. the number of orbits with at least one hit). """

non_empty = df.groupby(['ORBIT_CNT'])
non_empty = non_empty.count()
print(len(non_empty))

"""7. Count the number of unique orbits with at least one measurement from TDC_CHANNEL=139."""

unique_orbits = df[df['TDC_CHANNEL'] == 139]['ORBIT_CNT'].unique()
print(len(unique_orbits))

"""8. Create two Series (one for each FPGA) that have the TDC channel as index, and the number of counts for the corresponding TDC channel as values."""

FPGA0 = df[df['FPGA'] == 0]
FPGA0 = pd.Series(df[['TDC_CHANNEL']].value_counts())
print(FPGA0)

FPGA1 = df[df['FPGA'] == 1] 
FPGA1 = pd.Series(df[['TDC_CHANNEL']].value_counts())
print(FPGA1)